---
title: "HistogramZoo"
author: "Helen Zhu & Stefan Eng"
output:
  rmarkdown:::html_vignette:
    toc: true
bibliography: >
  references.bib  
vignette: >
  %\VignetteIndexEntry{HistogramZoo}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning=FALSE, message=FALSE, width=500)
options(max.print=35)

library(HistogramZoo)

```

# Introduction
The HistogramZoo R package is a collection of functions which aim to identify and characterize patterns from histogram data.

# The Histogram and GenomicHistogram class

A **Histogram** object contains 1 piece of essential data and 4 pieces of optional data:

* **histogram_data** is a numeric vector representing the histogram density

* **interval_start** and **histogram_end** are numeric vectors representing the start and end coordinates of each bin

* **bin_width** is a numeric indicator of the numeric length of bins. This can be automatically estimated from `interval_start` and `interval_end`

* **region_id** is a character id for the histogram

A **GenomicHistogram** object contains 2 additional pieces of optional data: **chr** for chromosome and **strand** for strand which is restricted to one of `+`, `-` and `*`. A Histogram and a GenomicHistogram differ in one of several key ways:

1. Conceptualization of bins: `Histogram` objects represent conventional histograms where data are binned on a real number scale. Starts are closed while ends are open with the exception of the last bin where both start and end are closed. `GenomicHistogram` objects were designed to represent a discrete [base 1](https://www.biostars.org/p/84686/) system where each histogram bin represents a set of indices on which observations are collected.

2. Restrictions on `bin_width`: `Histogram` objects require that the length of each bin is equal with the exception of the last bin which can be shorter than the rest. `GenomicHistogram` objects allow the lengths of each bin to vary as long as they are shorter or equal to the the designated `bin_width` and leaves the equal distribution of bin lengths up to user discretion. This allows users to construct `GenomicHistogram` objects using the `tile` and `binnedAverage` functions of `GenomicRanges`.

3. Disjoint intervals: Both `Histogram` and `GenomicHistogram` objects support the use of disjoint intervals but this feature was designed with `GenomicHistogram` objects in mind to support the representation of transcripts and genes as a set of exons which might not be consecutive intervals on the genomic coordinate system.

```{r Histogram_example, include=TRUE, out.width="50%"}

# TODO: Add an example for GenomicHistogram

my_histogram <- Histogram(
  histogram_data = c(1,2,3,1,5,6),
  interval_start = c(0,1,2,3,4,5),
  interval_end = c(1,2,3,4,5,6),
  bin_width = 1,
  region_id = "my_histogram"
)

create_coverageplot(
  my_histogram,
  main.cex = 1,
  xaxis.tck = 0, 
  yaxis.tck = 0, 
  xlab.cex = 1, 
  ylab.cex = 1, 
  xaxis.cex = 0.8, 
  yaxis.cex = 0.8,
  xat = generate_xlabels(my_histogram, n_labels = length(my_histogram), return_xat = T), 
  xaxis.lab = generate_xlabels(my_histogram, n_labels = length(my_histogram)), 
)

```

# Data loaders

## Data loaders for `Histogram` objects

**observations_to_histogram** bins a set of observations at a designated `histogram_bin_width` to generate a `Histogram`

```{r observations_to_histogram, include=TRUE, out.width="50%"}

set.seed(314)
my_data <- rnorm(10000, mean = 10, sd = 5)
my_histogram <- observations_to_histogram(my_data, histogram_bin_width = 1)

create_coverageplot(
  my_histogram, 
  main.cex = 0, 
  xaxis.tck = 0, 
  yaxis.tck = 0, 
  xlab.cex = 1, 
  ylab.cex = 1, 
  xaxis.cex = 0.8, 
  yaxis.cex = 0.8
)

```

## Data loaders for `GenomicHistogram` objects

**bigWig_to_histogram** bins the coverage from a single bigWig file on a set of user-defined regions (provided as a GRanges object, a GRangesList* object or a GTF file) and returns a list of GenomicHistogram objects. 

```{r bigWig_to_histogram, include=TRUE, out.width="50%"}

library(GenomicRanges)

filename <- system.file("extdata", "bigwigs",  "S1.bw", package = "HistogramZoo")

regions <- GenomicRanges::GRanges(
  seqnames = "chr1",
  IRanges::IRanges(
    start = c(17950, 19350),
    end = c(18000, 19600)),
  strand = "*"
)

bigwig_histograms <- bigWig_to_histogram(
  filename = filename,
  regions = regions,
  histogram_bin_size = 10
)

```

**genome_BED_to_histogram** bins the coverage from a set of genomic BED files and returns a list of GenomicHistogram objects. Users have the option of providing a set of regions as a GRanges or GRangesList* object.

```{r genome_BED_to_histogram, include=TRUE, out.width="50%"}

datadir <- system.file("extdata", "dna_bedfiles",  package = "HistogramZoo")
genome_bed_files <- list.files(datadir, pattern = ".bed$")
genome_bed_files <- file.path(datadir, genome_bed_files)

genome_bed_histograms <- genome_BED_to_histogram(
  filenames = genome_bed_files,
  n_fields = 6,
  histogram_bin_size = 1
)

```

**transcript_BED_to_histogram**, to account for overlapping transcript annotations, bins the coverage on a set of BED files where each element can be pre-assigned to a region using the 4th column (name) of the BED file. 

```{r transcript_BED_to_histogram, include=TRUE, out.width="50%"}

datadir <- system.file("extdata", "rna_bedfiles", package = "HistogramZoo")
transcript_bed_files <- file.path(datadir, paste0("Sample.", 1:20, ".bed"))
gtf <- system.file("extdata", "genes.gtf", package = "HistogramZoo")

histograms <- transcript_BED_to_histogram(
  filenames = transcript_bed_files,
  n_fields = 12,
  gtf = gtf,
  gene_or_transcript = "gene",
  histogram_bin_size = 10
)

```

### Notes on common parameters

* **regions** `[bigWig, genomic BED]`: Using a GRangesList object allows the assignment of disjoint intervals to a GenomicHistogram (e.g. representing a set of exons that can be joined to form a mature transcript) where each GRanges object in the GRangesList represents the elements of a single Histogram. Using a GRanges object creates a separate GenomicHistogram for each element in the GRanges object.

* **histogram_bin_size** `[bigWig, genomic and transcriptomic BED]`: Bins are generated using `GenomicRanges::tile` and coverage is calculated using `GenomicRanges::binnedAverage`. This strategy strives to create bins of equal size less than or equal to the designated `histogram_bin_size` (see above for discussion of the difference in `bin_width` restriction.)

* **allow_overlapping_segments_per_sample** `[transcriptomic and genomic BED]`: Each BED file is assumed to contain the elements of a single experimental sample. Thus, overlapping elements in each BED file can be eliminated by setting the parameter to `FALSE`.

# Segmentation and Distribution Fitting

The function **segment_and_fit** is designed to be a pipeline constructed from the following sub-functions which enables the segmentation, denoising and fitting of statistical distributions on Histogram and GenomicHistogram objects. Each of the parameters in `segment_and_fit` have counterparts in the sub-functions which is explored in further detail below.

## Finding local optima

**find_local_optima** identifies the local minima and maxima on a vector of counts (histogram data).

```{r find_local_optima_basic, include=TRUE, out.width="50%"}

# Generating a Histogram 
set.seed(314)
dt = rnorm(10000, mean = 20, sd = 10)
xhist = observations_to_histogram(dt, histogram_bin_width = 2)
data = xhist$histogram_data

# basic use
optima = find_local_optima(data)
optima = sort(unlist(optima))

create_coverageplot(
  xhist, 
  add.points = T, 
  points.x = optima, 
  points.y = data[optima], 
  points.col = "red",
  main = "basic optima",
  main.cex = 1, 
  xaxis.tck = 0, 
  yaxis.tck = 0, 
  xlab.cex = 1, 
  ylab.cex = 1, 
  xaxis.cex = 0.8, 
  yaxis.cex = 0.8
)

```

The parameter `threshold` allows the user to tune the sparsity of local optima to histograms with potentially noisy counts, i.e. by thresholding the difference between neighbouring optima.

```{r find_local_optima_threshold, include=TRUE, out.width="50%"}

# Generating a Histogram with noisy counts
set.seed(314)
dt = rnorm(1000, mean = 20, sd = 10)
xhist = observations_to_histogram(dt, histogram_bin_width = 1)
data = xhist$histogram_data

# find_local_optima with threshold 0
zero_threshold_optima = find_local_optima(data, threshold = 0)
zero_threshold_optima = sort(unlist(zero_threshold_optima))

create_coverageplot(
  xhist,
  add.points = T, 
  points.x = zero_threshold_optima,
  points.y = data[zero_threshold_optima],
  points.col = "red", 
  type = "h",
  main = "threshold = 0",
  main.cex = 1, 
  xaxis.tck = 0, 
  yaxis.tck = 0, 
  xlab.cex = 1, 
  ylab.cex = 1, 
  xaxis.cex = 0.8, 
  yaxis.cex = 0.8
)

# find_local_optima with threshold 2
threshold_optima = find_local_optima(data, threshold = 2)
threshold_optima = sort(unlist(threshold_optima))

create_coverageplot(
  xhist, 
  add.points = T, 
  points.x = threshold_optima, 
  points.y = data[threshold_optima], 
  points.col = "red", 
  type = "h",
  main = "threshold = 2",
  main.cex = 1, 
  xaxis.tck = 0, 
  yaxis.tck = 0, 
  xlab.cex = 1, 
  ylab.cex = 1, 
  xaxis.cex = 0.8, 
  yaxis.cex = 0.8
)


```


The parameter `flat_endpoints` allows the user to better fit histograms with stretches of equal values (e.g. pile-ups of BED files in a GenomicHistogram). Setting the parameter to `TRUE` will allow the user to return both endpoints of a flat region while setting the parameter to `FALSE` will return the estimated midpoint of a flat region.

```{r find_local_optima_stepfunction, include=TRUE, out.width="50%"}

# Generating a Histogram with consecutive equal values
data = c(rep(1, 3), rep(2, 4), rep(3, 3), rep(2, 1), rep(1, 5))
xhist = Histogram(histogram_data = data)

# flat_endpoints
optima_flat = find_local_optima(data, flat_endpoints = TRUE)
optima_flat = sort(unlist(optima_flat))

create_coverageplot(
  xhist, 
  add.points = T, 
  points.x = optima_flat, 
  points.y = data[optima_flat], 
  points.col = "red",
  main = "flat endpoints",
  main.cex = 1, 
  xaxis.tck = 0, 
  yaxis.tck = 0, 
  xlab.cex = 1, 
  ylab.cex = 1, 
  xaxis.cex = 0.8, 
  yaxis.cex = 0.8
)

# midpoints
optima_midpoints = find_local_optima(data, flat_endpoints = FALSE)
optima_midpoints = sort(unlist(optima_midpoints))

create_coverageplot(
  xhist, 
  add.points = T, 
  points.x = optima_midpoints, 
  points.y = data[optima_midpoints], 
  points.col = "red",
  main = "midpoints",
  main.cex = 1, 
  xaxis.tck = 0, 
  yaxis.tck = 0, 
  xlab.cex = 1, 
  ylab.cex = 1, 
  xaxis.cex = 0.8, 
  yaxis.cex = 0.8
)

```

## The Fine-to-Coarse segmentation algorithm

The Fine-to-Coarse segmentation algorithm was described in @delon2005color.

## Filtering Low Entropy Regions

## Fitting Statistical Distributions

1. Truncated Distributions

2. Maximizing Uniform Elements

3. Metrics & Voting

# Exporting Results

## Summary statistics

*  `summarize_results` can be applied to a `HistogramFit` object to extract the indices and summary statistics of the analysis.

A data frame will be returned with the following columns.

## Plotting

Several plotting functions are available to aid with the visualization of results. Plotting functions can be combined with plotting capabilities from `BoutrosLab.plotting.general` [@p2019bpg] based on the `lattice` R package [@sarkar2015package].

* `create_coverageplot` can be used to visualize the `Histogram`, `GenomicHistogram` or `HistogramFit` object with annotated segmentation points and distributions.

* `create_residualplot` can be used to visualize the residuals between the fitted and observed distributions of a `HistogramFit` object

* `create_trackplot` can be used to add complementary tracks to a histogram visualization when combined with `create_layerplot`

* `create_layerplot` can be used to create a multipanel plot with combinations of coverage, residual and track plots.

```{r plotting, include=FALSE}


```

# References
